#!/usr/bin/env nix-shell
#!nix-shell -i bash -p bash -p coreutils-full -p iproute2 -p jq -p sane-scripts.ip-check -p systemd

set -e

usageDescription() {
  echo "sane-vpn: tool to route all system internet traffic through some VPN, or just one application's"
  echo 'and, thanks to cap_net_admin, we can do all this without superuser!'
  echo "however, systemd --user has poor support for capabilities, hence this here is a bespoke script instead of a service"
  echo ""
  echo "usage:"
  echo "sane-vpn [flags ...] operation [operation flags]"
  echo ""
  echo "flags:"
  echo "  --debug"
  echo "  --no-proxy-dns"
  echo ""
  echo "operations:"
  echo "sane-vpn up [REGION]"
  echo "sane-vpn down [REGION]"
  echo "sane-vpn do [REGION [COMMAND ...] ]"
  echo "sane-vpn do -- [COMMAND ...]"
  echo "sane-vpn help"
  echo ""
  echo "idioms:"
  echo "- sane-vpn do none [COMMAND ...]"
  echo "  - run the command with a stub resolver instead of my recursive resolver, but no VPN."
  echo "- sane-vpn up none"
  echo "  - patch the entire system to use a stub resolver, but no VPN."
  echo "- sane-vpn --no-proxy-dns up -- [COMMAND ...]"
  echo "  - patch the system to route all traffic over the VPN, but use our stub resolver (still through the VPN) instead of delegating to the VPN owner's resolver"
}


## GLOBALS, POPULATED LATER:
# region, populated from CLI: should be e.g. `us` or `ukr`
region=
# vpn names: populated from ~/.config/sane-vpn
vpns=()
defaultVpn=

# loaded from a specific ~/.config/sane-vpn/vpns profile
addrV4=
dns=()
fwmark=
id=
name=
priorityFwMark=
priorityMain=

debug() {
  if [ -n "$SANE_VPN_DEBUG" ]; then
    printf "%s\n" "$@"
  fi
}

# load VPN names from disk
getVpns() {
  vpns=($(ls ~/.config/sane-vpn/vpns))
  defaultVpn="$(cat ~/.config/sane-vpn/default)"
  debug "default vpn: $defaultVpn"
}

# load a specific VPN profile, `"$1"`
sourceVpn() {
  # populates: variables declared above
  debug "sourcing: ~/.config/sane-vpn/vpns/$1"
  # TODO: don't blindly source this, but parse explicitly as `K=V`
  source ~/.config/sane-vpn/vpns/$1
}

canonicalizeRegion() {
  debug "region before canonicalization: '$region'"
  for v in "${vpns[@]}"; do
    if [ "ovpnd-$region" = "$v" ]; then
      debug "canonicalizing shorthand ovpnd- region to '$v'"
      region="$v"
    fi
  done

  if [ -z "$region" ] || [ "$region" = "default" ] || [ "$region" = "-" ] || [ "$region" = "--" ]; then
    debug "canonicalizing default region to '$defaultVpn'"
    region="$defaultVpn"
  fi
  debug "region after canonicalization: '$region'"
}

fixupCommand() {
  command=("$@")
  if [ ${#command} -eq 0 ]; then
    command=("$SHELL")
  fi
}

vpnToggle() {
  local verb="$1"

  debug "vpnToggle with:"
  debug "  id='$id'"
  debug "  dns='$dns'"
  debug "  fwmark='$fwmark'"
  debug "  priorityMain='$priorityMain'"
  debug "  priorityFwMark='$priorityFwMark'"

  set +e
  echo before: $(sane-ip-check --no-upnp --retry-duration 2)
  set -e

  if [ "$region" != none ]; then
    # first, allow all non-default routes (prefix-length != 0) a chance to route the packet.
    # - this allows the wireguard tunnel itself to pass traffic via our LAN gateway.
    # - incidentally, it allows traffic to LAN devices and other machine-local or virtual networks.
    ip rule "$verb" from all lookup main suppress_prefixlength 0 priority "$priorityMain"

    # if packet hasn't gone through the wg device yet (fwmark), then move it to the table which will cause it to.
    ip rule "$verb" not from all fwmark "$fwmark" lookup "$id" priority "$priorityFwMark"
  fi

  dnsToggle "$verb"

  echo after:  $(sane-ip-check --no-upnp)
}

dnsToggle() {
  # forward DNS to the VPN's resolver.
  # we don't generally need to do this. only makes sense if our local recursive resolver isn't up to the job.
  local verb="$1"
  local zone=
  if [ -n "$dns" ] && [ "$verb" = add ]; then
    zone="
      [[zones]]
      zone = \".\"
      zone_type = \"Forward\"
      stores = { type = \"forward\", name_servers = [
          { socket_addr = \"$dns:53\", protocol = \"udp\", trust_nx_responses = false }
      ]}
    "
  fi
  echo "$zone" > /var/lib/trust-dns/dhcp-configs/sane-vpn.toml
  systemctl restart trust-dns-localhost
}

vpnDo() {
  debug "vpnDo with:"
  debug "  name='$name'"
  debug "  addrV4='$addrV4'"
  debug "  dns='$dns'"
  debug "command: ${command[*]}"
  local netFlags=${dns:+ --sanebox-dns $dns}${name:+ --sanebox-net-dev $name}${addrV4:+ --sanebox-net-gateway $addrV4}
  # sanebox --sanebox-method pastaonly $netFlags "${command[@]}"
  sanebox --sanebox-method bwrap --sanebox-keep-namespace all --sanebox-path / --sanebox-no-portal \
    $netFlags \
    "${command[@]}"
}

usage() {
  local rc="$1"
  local msg="$2"

  test -n "$msg" && echo "$msg"

  usageDescription
  echo ""
  echo "regions:"
  for v in "${vpns[@]}"; do
    echo "- $v"
  done

  test -n "$rc" && exit "$rc"
}

parseCli() {
  local noProxyDns=
  while [ $# -ne 0 ]; do
    local arg="$1"
    case "$arg" in
      (--debug)
        SANE_VPN_DEBUG=1
        shift
        ;;
      (--no-proxy-dns)
        noProxyDns=1
        shift
        ;;
      (-*)
        usage 1 "unexpected flag: $arg"
        ;;
      (*)
        break
        ;;
    esac
  done

  local oper="$1"
  shift
  region="$1"
  shift || true

  getVpns
  canonicalizeRegion
  fixupCommand "$@"
  if [ "$region" == none ]; then
    name=$(ip -j route get 255 | jq --raw-output '.[0]["dev"]')
    dns=(1.1.1.1 8.8.8.8)
  else
    sourceVpn "$region"
  fi

  if [ -n "$noProxyDns" ]; then
    dns=()
  fi

  case $oper in
    (up)
      vpnToggle add
      ;;
    (down)
      vpnToggle del
      ;;
    (do)
      vpnDo "$@"
      ;;
    (--help|help|"")
      usage 0
      ;;
    (*)
      usage 1 "invalid operation '$oper'"
      ;;
  esac
}

parseCli "$@"
