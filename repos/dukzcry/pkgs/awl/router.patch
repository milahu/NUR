patch similar to
https://github.com/mudler/edgevpn/pull/2
diff --git a/config/config.go b/config/config.go
index 14d9ed9..6968386 100644
--- a/config/config.go
+++ b/config/config.go
@@ -66,6 +66,7 @@ type (
 	VPNConfig struct {
 		InterfaceName string `json:"interfaceName"`
 		IPNet         string `json:"ipNet"`
+		Router        string `json:"router"`
 	}
 	KnownPeer struct {
 		// Hex-encoded multihash representing a peer ID
@@ -88,6 +89,7 @@ type (
 		Declined               bool `json:"declined"`
 		WeAllowUsingAsExitNode bool `json:"weAllowUsingAsExitNode"`
 		AllowedUsingAsExitNode bool `json:"allowedUsingAsExitNode"`
+		Network string `json:"network"`
 	}
 	BlockedPeer struct {
 		// Hex-encoded multihash representing a peer ID
diff --git a/protocol/protocol.go b/protocol/protocol.go
index 61b0349..9c45895 100644
--- a/protocol/protocol.go
+++ b/protocol/protocol.go
@@ -23,6 +23,7 @@ type (
 		Name                 string
 		Declined             bool
 		AllowUsingAsExitNode bool
+		Network              string
 	}
 )
 
diff --git a/service/auth_status.go b/service/auth_status.go
index 726dd89..ed90359 100644
--- a/service/auth_status.go
+++ b/service/auth_status.go
@@ -161,6 +161,7 @@ func (s *AuthStatus) createPeerInfo(peer config.KnownPeer, myPeerName string, de
 	myPeerInfo := protocol.PeerStatusInfo{
 		Name:                 myPeerName,
 		AllowUsingAsExitNode: peer.WeAllowUsingAsExitNode,
+		Network:              s.conf.VPNConfig.IPNet,
 	}
 
 	return myPeerInfo
@@ -182,6 +183,7 @@ func (s *AuthStatus) processPeerStatusInfo(peer config.KnownPeer, peerInfo proto
 		peer.Alias = s.conf.GenUniqPeerAlias(peer.Name, peer.Alias)
 	}
 	peer.AllowedUsingAsExitNode = peerInfo.AllowUsingAsExitNode
+	peer.Network = peerInfo.Network
 
 	return peer
 }
diff --git a/service/tunnel.go b/service/tunnel.go
index 81ce29f..5a2ae5f 100644
--- a/service/tunnel.go
+++ b/service/tunnel.go
@@ -29,6 +29,7 @@ type Tunnel struct {
 	peersLock    sync.RWMutex
 	peerIDToPeer map[peer.ID]*VpnPeer
 	netIPToPeer  map[string]*VpnPeer
+	router       net.IP
 }
 
 func NewTunnel(p2pService P2p, device *vpn.Device, conf *config.Config) *Tunnel {
@@ -39,6 +40,7 @@ func NewTunnel(p2pService P2p, device *vpn.Device, conf *config.Config) *Tunnel
 		logger:       log.Logger("awl/service/tunnel"),
 		peerIDToPeer: make(map[peer.ID]*VpnPeer),
 		netIPToPeer:  make(map[string]*VpnPeer),
+		router:       net.ParseIP(conf.VPNConfig.Router).To4(),
 	}
 	tunnel.RefreshPeersList()
 	go tunnel.backgroundReadPackets()
@@ -115,12 +117,17 @@ func (t *Tunnel) RefreshPeersList() {
 			t.logger.Errorf("Known peer %q has invalid IP %s in conf", knownPeer.DisplayName(), knownPeer.IPAddr)
 			return
 		}
+		_, network, err := net.ParseCIDR(knownPeer.Network)
+		if err != nil {
+			network = nil
+		}
 
 		vpnPeer := &VpnPeer{
 			peerID:     peerID,
 			localIP:    localIP,
 			inboundCh:  make(chan *vpn.Packet, packetHandlersChanCap),
 			outboundCh: make(chan *vpn.Packet, packetHandlersChanCap),
+			network:    network,
 		}
 		t.peerIDToPeer[peerID] = vpnPeer
 		t.netIPToPeer[string(localIP)] = vpnPeer
@@ -154,6 +161,9 @@ func (t *Tunnel) backgroundReadPackets() {
 	for packet := range t.device.OutboundChan() {
 		t.peersLock.RLock()
 		vpnPeer, ok := t.netIPToPeer[string(packet.Dst)]
+		if !ok && t.router != nil {
+			vpnPeer, ok = t.netIPToPeer[string(t.router)]
+		}
 		if !ok {
 			t.device.PutTempPacket(packet)
 			t.peersLock.RUnlock()
@@ -187,6 +197,7 @@ type VpnPeer struct {
 	localIP    net.IP
 	inboundCh  chan *vpn.Packet
 	outboundCh chan *vpn.Packet // from us to remote
+	network    *net.IPNet
 }
 
 // TODO: remove Tunnel from VpnPeer dependencies
@@ -280,7 +291,7 @@ func (vp *VpnPeer) backgroundInboundHandler(t *Tunnel) {
 			t.device.PutTempPacket(packet)
 			continue
 		}
-		err := t.device.WritePacket(packet, vp.localIP)
+		err := t.device.WritePacket(packet, vp.localIP, vp.network)
 		if err != nil {
 			t.logger.Warnf("write packet to vpn: %v", err)
 		}
diff --git a/vpn/vpn.go b/vpn/vpn.go
index 22a1cea..096dd6e 100644
--- a/vpn/vpn.go
+++ b/vpn/vpn.go
@@ -80,13 +80,17 @@ func (d *Device) PutTempPacket(data *Packet) {
 }
 
 // TODO: batch write
-func (d *Device) WritePacket(data *Packet, senderIP net.IP) error {
+func (d *Device) WritePacket(data *Packet, senderIP net.IP, network *net.IPNet) error {
 	if data.IsIPv6 {
 		// TODO: implement. We need to set Device.localIP ipv6 instead of ipv4
 		return nil
 	} else {
-		copy(data.Src, senderIP)
-		copy(data.Dst, d.localIP)
+		if network == nil || network.Contains(data.Src) {
+			copy(data.Src, senderIP)
+		}
+		if network == nil || network.Contains(data.Dst) {
+			copy(data.Dst, d.localIP)
+		}
 	}
 	data.RecalculateChecksum()
 
