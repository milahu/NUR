error:
… from call site

  at ./default.nix:107:40:

   106|
   107|   kotatogram-desktop-with-patched-qt = desktop-app.with-patched-qt kotatogram-desktop;
      |                                        ^
   108|

… while calling 'with-patched-qt'

  at ./default.nix:76:23:

    75|
    76|     with-patched-qt = drv: (lib.foldr ({ oldDependency, newDependency }: drv:
      |                       ^
    77|       replaceDependency { inherit oldDependency newDependency drv; }

… from call site

  at ./default.nix:76:29:

    75|
    76|     with-patched-qt = drv: (lib.foldr ({ oldDependency, newDependency }: drv:
      |                             ^
    77|       replaceDependency { inherit oldDependency newDependency drv; }

… while calling 'foldr'

  at <nixpkgs> + /lib/lists.nix:139:14:

   138|   foldr =
   139|     op: nul: list:
      |              ^
   140|     let

… from call site

  at <nixpkgs> + /lib/lists.nix:144:5:

   143|     in
   144|     fold' 0;
      |     ^
   145|

… while calling 'fold''

  at <nixpkgs> + /lib/lists.nix:142:15:

   141|       len = length list;
   142|       fold' = n: if n == len then nul else op (elemAt list n) (fold' (n + 1));
      |               ^
   143|     in

… from call site

  at <nixpkgs> + /lib/lists.nix:142:44:

   141|       len = length list;
   142|       fold' = n: if n == len then nul else op (elemAt list n) (fold' (n + 1));
      |                                            ^
   143|     in

… while calling anonymous lambda

  at ./default.nix:76:74:

    75|
    76|     with-patched-qt = drv: (lib.foldr ({ oldDependency, newDependency }: drv:
      |                                                                          ^
    77|       replaceDependency { inherit oldDependency newDependency drv; }

… from call site

  at ./default.nix:77:7:

    76|     with-patched-qt = drv: (lib.foldr ({ oldDependency, newDependency }: drv:
    77|       replaceDependency { inherit oldDependency newDependency drv; }
      |       ^
    78|     ) drv ([

… while calling 'replaceDependency'

  at <nixpkgs> + /pkgs/top-level/all-packages.nix:857:5:

   856|   replaceDependency =
   857|     {
      |     ^
   858|       drv,

… from call site

  at <nixpkgs> + /lib/trivial.nix:989:5:

   988|     # TODO: Should we add call-time "type" checking like built in?
   989|     __functor = self: f;
      |     ^
   990|     __functionArgs = args;

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:35:1:

    34| # The cutoffPackages argument can be used to exempt the problematic packages from the replacement process.
    35| {
      | ^
    36|   drv,

… from call site

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:136:24:

   135|   );
   136|   relevantReferences = mergeAttrsList (attrValues referencesMemo);
      |                        ^
   137|   # Make sure a derivation is returned even when no replacements are actually applied.

… while calling 'mergeAttrsList'

  at <nixpkgs> + /lib/attrsets.nix:1447:5:

  1446|   mergeAttrsList =
  1447|     list:
      |     ^
  1448|     let

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:114:5:

   113|   relevantReplacements = filter (
   114|     { oldDependency, newDependency }:
      |     ^
   115|     if toString oldDependency == toString newDependency then

… from call site

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:112:20:

   111|       );
   112|   rootReferences = referencesOf drv;
      |                    ^
   113|   relevantReplacements = filter (

… while calling 'referencesOf'

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:60:5:

    59|   referencesOf =
    60|     drv:
      |     ^
    61|     import

… while evaluating derivation 'references.nix'
  whose name attribute is located at <nixpkgs> + /pkgs/stdenv/generic/make-derivation.nix:438:13

… while evaluating attribute 'exportReferencesGraph' of derivation 'references.nix'

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:64:11:

    63|         {
    64|           exportReferencesGraph = [
      |           ^
    65|             "graph"

… from call site

  at <nixpkgs> + /lib/lists.nix:142:64:

   141|       len = length list;
   142|       fold' = n: if n == len then nul else op (elemAt list n) (fold' (n + 1));
      |                                                                ^
   143|     in

… while calling 'fold''

  at <nixpkgs> + /lib/lists.nix:142:15:

   141|       len = length list;
   142|       fold' = n: if n == len then nul else op (elemAt list n) (fold' (n + 1));
      |               ^
   143|     in

… from call site

  at <nixpkgs> + /lib/lists.nix:142:44:

   141|       len = length list;
   142|       fold' = n: if n == len then nul else op (elemAt list n) (fold' (n + 1));
      |                                            ^
   143|     in

… while calling anonymous lambda

  at ./default.nix:76:74:

    75|
    76|     with-patched-qt = drv: (lib.foldr ({ oldDependency, newDependency }: drv:
      |                                                                          ^
    77|       replaceDependency { inherit oldDependency newDependency drv; }

… from call site

  at ./default.nix:77:7:

    76|     with-patched-qt = drv: (lib.foldr ({ oldDependency, newDependency }: drv:
    77|       replaceDependency { inherit oldDependency newDependency drv; }
      |       ^
    78|     ) drv ([

… while calling 'replaceDependency'

  at <nixpkgs> + /pkgs/top-level/all-packages.nix:857:5:

   856|   replaceDependency =
   857|     {
      |     ^
   858|       drv,

… from call site

  at <nixpkgs> + /lib/trivial.nix:989:5:

   988|     # TODO: Should we add call-time "type" checking like built in?
   989|     __functor = self: f;
      |     ^
   990|     __functionArgs = args;

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:35:1:

    34| # The cutoffPackages argument can be used to exempt the problematic packages from the replacement process.
    35| {
      | ^
    36|   drv,

… from call site

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:136:24:

   135|   );
   136|   relevantReferences = mergeAttrsList (attrValues referencesMemo);
      |                        ^
   137|   # Make sure a derivation is returned even when no replacements are actually applied.

… while calling 'mergeAttrsList'

  at <nixpkgs> + /lib/attrsets.nix:1447:5:

  1446|   mergeAttrsList =
  1447|     list:
      |     ^
  1448|     let

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:114:5:

   113|   relevantReplacements = filter (
   114|     { oldDependency, newDependency }:
      |     ^
   115|     if toString oldDependency == toString newDependency then

… while evaluating derivation 'qtwayland-6.9.0'
  whose name attribute is located at <nixpkgs> + /pkgs/stdenv/generic/make-derivation.nix:438:13

… while evaluating attribute 'propagatedBuildInputs' of derivation 'qtwayland-6.9.0'

  at <nixpkgs> + /pkgs/stdenv/generic/make-derivation.nix:500:13:

   499|             depsHostHostPropagated = elemAt (elemAt propagatedDependencies 1) 0;
   500|             propagatedBuildInputs = elemAt (elemAt propagatedDependencies 1) 1;
      |             ^
   501|             depsTargetTargetPropagated = elemAt (elemAt propagatedDependencies 2) 0;

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/stdenv/generic/make-derivation.nix:424:19:

   423|             ))
   424|             (map (drv: getDev drv.__spliced.hostTarget or drv) (
      |                   ^
   425|               checkDependencyList "propagatedBuildInputs" propagatedBuildInputs

… from call site

  at <nixpkgs> + /pkgs/stdenv/generic/make-derivation.nix:424:24:

   423|             ))
   424|             (map (drv: getDev drv.__spliced.hostTarget or drv) (
      |                        ^
   425|               checkDependencyList "propagatedBuildInputs" propagatedBuildInputs

… while calling 'getOutput'

  at <nixpkgs> + /lib/attrsets.nix:1745:13:

  1744|   getOutput =
  1745|     output: pkg:
      |             ^
  1746|     if !pkg ? outputSpecified || !pkg.outputSpecified then pkg.${output} or pkg.out or pkg else pkg;

… while calling anonymous lambda

  at <nixpkgs> + /lib/lists.nix:345:29:

   344|   */
   345|   imap1 = f: list: genList (n: f (n + 1) (elemAt list n)) (length list);
      |                             ^
   346|

… from call site

  at <nixpkgs> + /lib/lists.nix:345:32:

   344|   */
   345|   imap1 = f: list: genList (n: f (n + 1) (elemAt list n)) (length list);
      |                                ^
   346|

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/stdenv/generic/make-derivation.nix:348:18:

   347|         imap1 (
   348|           index: dep:
      |                  ^
   349|           if dep == null || isDerivation dep || builtins.isString dep || builtins.isPath dep then

… from call site

  at ./default.nix:59:23:

    58|       inherit qtbase;
    59|       qtdeclarative = replaceDependency {
      |                       ^
    60|         oldDependency = qt6.qtbase;

… while calling 'replaceDependency'

  at <nixpkgs> + /pkgs/top-level/all-packages.nix:857:5:

   856|   replaceDependency =
   857|     {
      |     ^
   858|       drv,

… from call site

  at <nixpkgs> + /lib/trivial.nix:989:5:

   988|     # TODO: Should we add call-time "type" checking like built in?
   989|     __functor = self: f;
      |     ^
   990|     __functionArgs = args;

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:35:1:

    34| # The cutoffPackages argument can be used to exempt the problematic packages from the replacement process.
    35| {
      | ^
    36|   drv,

… from call site

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:136:24:

   135|   );
   136|   relevantReferences = mergeAttrsList (attrValues referencesMemo);
      |                        ^
   137|   # Make sure a derivation is returned even when no replacements are actually applied.

… while calling 'mergeAttrsList'

  at <nixpkgs> + /lib/attrsets.nix:1447:5:

  1446|   mergeAttrsList =
  1447|     list:
      |     ^
  1448|     let

… while calling anonymous lambda

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:114:5:

   113|   relevantReplacements = filter (
   114|     { oldDependency, newDependency }:
      |     ^
   115|     if toString oldDependency == toString newDependency then

… from call site

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:112:20:

   111|       );
   112|   rootReferences = referencesOf drv;
      |                    ^
   113|   relevantReplacements = filter (

… while calling 'referencesOf'

  at <nixpkgs> + /pkgs/build-support/replace-dependencies.nix:60:5:

    59|   referencesOf =
    60|     drv:
      |     ^
    61|     import

error: path '/nix/store/n3p83rylywwpsgls1zn8j1b2ki3qqxc5-references.nix.drv' is not valid
